{
  "version": 3,
  "sources": ["../../mitt/src/index.ts", "../../@threlte/core/dist/frame-scheduling/DAG.js", "../../@threlte/core/dist/frame-scheduling/Task.js", "../../@threlte/core/dist/frame-scheduling/Stage.js", "../../@threlte/core/dist/frame-scheduling/Scheduler.js", "../../@threlte/core/dist/lib/storeUtils.js", "../../@threlte/core/dist/lib/defaultCamera.js", "../../@threlte/core/dist/hooks/legacy/utils.js", "../../@threlte/core/dist/lib/contexts.js", "../../@threlte/core/dist/lib/browser.js", "../../@threlte/core/dist/hooks/useParentSize.js", "../../@threlte/core/dist/lib/createObjectStore.js", "../../@threlte/core/dist/hooks/useThrelte.js", "../../@threlte/core/dist/hooks/useParent.js", "../../@threlte/core/dist/internal/HierarchicalObject.svelte", "../../@threlte/core/dist/internal/SceneGraphObject.svelte", "../../@threlte/core/dist/lib/cache.js", "../../@threlte/core/dist/lib/revision.js", "../../@threlte/core/dist/lib/useRenderer.js", "../../@threlte/core/dist/hooks/useThrelteInternal.js", "../../@threlte/core/dist/Canvas.svelte", "../../@threlte/core/dist/internal/DisposableObject.svelte", "../../@threlte/core/dist/components/T/utils/utils.js", "../../@threlte/core/dist/components/T/utils/resolvePropertyPath.js", "../../@threlte/core/dist/components/T/utils/useAttach.js", "../../@threlte/core/dist/components/T/utils/useCamera.js", "../../@threlte/core/dist/lib/createRawEventDispatcher.js", "../../@threlte/core/dist/components/T/utils/useCreateEvent.js", "../../@threlte/core/dist/components/T/utils/useEvents.js", "../../@threlte/core/dist/components/T/utils/usePlugins.js", "../../@threlte/core/dist/components/T/utils/useProps.js", "../../@threlte/core/dist/components/T/T.svelte", "../../@threlte/core/dist/components/T/T.js", "../../@threlte/core/dist/plugins/injectPlugin.js", "../../@threlte/core/dist/plugins/createPlugin.js", "../../@threlte/core/dist/hooks/useTask.js", "../../@threlte/core/dist/hooks/useStage.js", "../../@threlte/core/dist/hooks/useThrelteUserContext.js", "../../@threlte/core/dist/hooks/legacy/useFrame.js", "../../@threlte/core/dist/hooks/legacy/useRender.js", "../../@threlte/core/dist/lib/asyncWritable.js", "../../@threlte/core/dist/hooks/useLoader.js", "../../@threlte/core/dist/lib/forwardEventHandlers.js"],
  "sourcesContent": ["export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = unknown> = (event: T) => void;\nexport type WildcardHandler<T = Record<string, unknown>> = (\n\ttype: keyof T,\n\tevent: T[keyof T]\n) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList<T = unknown> = Array<Handler<T>>;\nexport type WildCardEventHandlerList<T = Record<string, unknown>> = Array<\n\tWildcardHandler<T>\n>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap<Events extends Record<EventType, unknown>> = Map<\n\tkeyof Events | '*',\n\tEventHandlerList<Events[keyof Events]> | WildCardEventHandlerList<Events>\n>;\n\nexport interface Emitter<Events extends Record<EventType, unknown>> {\n\tall: EventHandlerMap<Events>;\n\n\ton<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): void;\n\ton(type: '*', handler: WildcardHandler<Events>): void;\n\n\toff<Key extends keyof Events>(\n\t\ttype: Key,\n\t\thandler?: Handler<Events[Key]>\n\t): void;\n\toff(type: '*', handler: WildcardHandler<Events>): void;\n\n\temit<Key extends keyof Events>(type: Key, event: Events[Key]): void;\n\temit<Key extends keyof Events>(\n\t\ttype: undefined extends Events[Key] ? Key : never\n\t): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt<Events extends Record<EventType, unknown>>(\n\tall?: EventHandlerMap<Events>\n): Emitter<Events> {\n\ttype GenericEventHandler =\n\t\t| Handler<Events[keyof Events]>\n\t\t| WildcardHandler<Events>;\n\tall = all || new Map();\n\n\treturn {\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `'*'` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<Key extends keyof Events>(type: Key, handler: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.push(handler);\n\t\t\t} else {\n\t\t\t\tall!.set(type, [handler] as EventHandlerList<Events[keyof Events]>);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * If `handler` is omitted, all handlers of the given type are removed.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)\n\t\t * @param {Function} [handler] Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<Key extends keyof Events>(type: Key, handler?: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\tif (handler) {\n\t\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t\t} else {\n\t\t\t\t\tall!.set(type, []);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `'*'` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing '*' handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<Key extends keyof Events>(type: Key, evt?: Events[Key]) {\n\t\t\tlet handlers = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as EventHandlerList<Events[keyof Events]>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(evt!);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\thandlers = all!.get('*');\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as WildCardEventHandlerList<Events>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(type, evt!);\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n", "import mitt from 'mitt';\r\nexport class DAG {\r\n    allVertices = {};\r\n    /** Nodes that are fully unlinked */\r\n    isolatedVertices = {};\r\n    connectedVertices = {};\r\n    sortedConnectedValues = [];\r\n    needsSort = false;\r\n    emitter = mitt();\r\n    emit = this.emitter.emit.bind(this.emitter);\r\n    on = this.emitter.on.bind(this.emitter);\r\n    off = this.emitter.off.bind(this.emitter);\r\n    get sortedVertices() {\r\n        return this.mapNodes((value) => value);\r\n    }\r\n    moveToIsolated(key) {\r\n        const vertex = this.connectedVertices[key];\r\n        if (!vertex)\r\n            return;\r\n        this.isolatedVertices[key] = vertex;\r\n        delete this.connectedVertices[key];\r\n    }\r\n    moveToConnected(key) {\r\n        const vertex = this.isolatedVertices[key];\r\n        if (!vertex)\r\n            return;\r\n        this.connectedVertices[key] = vertex;\r\n        delete this.isolatedVertices[key];\r\n    }\r\n    getKey = (v) => {\r\n        if (typeof v === 'object') {\r\n            return v.key;\r\n        }\r\n        return v;\r\n    };\r\n    add(key, value, options) {\r\n        if (this.allVertices[key] && this.allVertices[key].value !== undefined) {\r\n            throw new Error(`A node with the key ${key.toString()} already exists`);\r\n        }\r\n        let vertex = this.allVertices[key];\r\n        if (!vertex) {\r\n            vertex = {\r\n                value: value,\r\n                previous: new Set(),\r\n                next: new Set()\r\n            };\r\n            // add the vertex to the list of all vertices\r\n            this.allVertices[key] = vertex;\r\n        }\r\n        else if (vertex.value === undefined) {\r\n            vertex.value = value;\r\n        }\r\n        // if another node referenced this node before, we have inverse links\r\n        const hasEdges = vertex.next.size > 0 || vertex.previous.size > 0;\r\n        if (!options?.after && !options?.before && !hasEdges) {\r\n            // the node we're about to add is fully unlinked\r\n            this.isolatedVertices[key] = vertex;\r\n            this.emit('node:added', {\r\n                key,\r\n                type: 'isolated',\r\n                value\r\n            });\r\n            return;\r\n        }\r\n        else {\r\n            this.connectedVertices[key] = vertex;\r\n        }\r\n        if (options?.after) {\r\n            const afterArr = Array.isArray(options.after) ? options.after : [options.after];\r\n            // we need to update the vertex to include the new \"after\" nodes\r\n            afterArr.forEach((after) => {\r\n                vertex.previous.add(this.getKey(after));\r\n            });\r\n            afterArr.forEach((after) => {\r\n                const afterKey = this.getKey(after);\r\n                // we get the vertex from the list of all vertices\r\n                const linkedAfter = this.allVertices[afterKey];\r\n                if (!linkedAfter) {\r\n                    // if it doesn't exist, we create it\r\n                    this.allVertices[afterKey] = {\r\n                        value: undefined,\r\n                        previous: new Set(),\r\n                        next: new Set([key])\r\n                    };\r\n                    this.connectedVertices[afterKey] = this.allVertices[afterKey];\r\n                }\r\n                else {\r\n                    // if it does exist, we update it\r\n                    linkedAfter.next.add(key);\r\n                    // we might need to move the vertex from isolated to connected\r\n                    this.moveToConnected(afterKey);\r\n                }\r\n            });\r\n        }\r\n        if (options?.before) {\r\n            const beforeArr = Array.isArray(options.before) ? options.before : [options.before];\r\n            // we need to update the vertex to include the new \"before\" nodes\r\n            beforeArr.forEach((before) => {\r\n                vertex.next.add(this.getKey(before));\r\n            });\r\n            beforeArr.forEach((before) => {\r\n                const beforeKey = this.getKey(before);\r\n                // we get the vertex from the list of all vertices\r\n                const linkedBefore = this.allVertices[beforeKey];\r\n                if (!linkedBefore) {\r\n                    // if it doesn't exist, we create it\r\n                    this.allVertices[beforeKey] = {\r\n                        value: undefined,\r\n                        previous: new Set([key]),\r\n                        next: new Set()\r\n                    };\r\n                    this.connectedVertices[beforeKey] = this.allVertices[beforeKey];\r\n                }\r\n                else {\r\n                    // if it does exist, we update it\r\n                    linkedBefore.previous.add(key);\r\n                    // we might need to move the vertex from isolated to connected\r\n                    this.moveToConnected(beforeKey);\r\n                }\r\n            });\r\n        }\r\n        this.emit('node:added', {\r\n            key,\r\n            type: 'connected',\r\n            value\r\n        });\r\n        // Mark the graph as needing a re-sort\r\n        this.needsSort = true;\r\n    }\r\n    remove(key) {\r\n        const removeKey = this.getKey(key);\r\n        // check if it's an unlinked vertex\r\n        const unlinkedVertex = this.isolatedVertices[removeKey];\r\n        if (unlinkedVertex) {\r\n            delete this.isolatedVertices[removeKey];\r\n            delete this.allVertices[removeKey];\r\n            this.emit('node:removed', {\r\n                key: removeKey,\r\n                type: 'isolated'\r\n            });\r\n            return;\r\n        }\r\n        // if it's not, it's a bit more complicated\r\n        const linkedVertex = this.connectedVertices[removeKey];\r\n        if (!linkedVertex) {\r\n            // The node does not exist in the graph.\r\n            return;\r\n        }\r\n        // Update the 'next' nodes that this node points to\r\n        linkedVertex.next.forEach((nextKey) => {\r\n            const nextVertex = this.connectedVertices[nextKey];\r\n            if (nextVertex) {\r\n                nextVertex.previous.delete(removeKey);\r\n                if (nextVertex.previous.size === 0 && nextVertex.next.size === 0) {\r\n                    this.moveToIsolated(nextKey);\r\n                }\r\n            }\r\n        });\r\n        // Update the 'previous' nodes that point to this node\r\n        linkedVertex.previous.forEach((prevKey) => {\r\n            const prevVertex = this.connectedVertices[prevKey];\r\n            if (prevVertex) {\r\n                prevVertex.next.delete(removeKey);\r\n                if (prevVertex.previous.size === 0 && prevVertex.next.size === 0) {\r\n                    this.moveToIsolated(prevKey);\r\n                }\r\n            }\r\n        });\r\n        // Finally, remove the node from the graph\r\n        delete this.connectedVertices[removeKey];\r\n        delete this.allVertices[removeKey];\r\n        this.emit('node:removed', {\r\n            key: removeKey,\r\n            type: 'connected'\r\n        });\r\n        // Mark the graph as needing a re-sort\r\n        this.needsSort = true;\r\n    }\r\n    mapNodes(callback) {\r\n        if (this.needsSort) {\r\n            this.sort();\r\n        }\r\n        const result = [];\r\n        this.forEachNode((value, index) => {\r\n            result.push(callback(value, index));\r\n        });\r\n        return result;\r\n    }\r\n    forEachNode(callback) {\r\n        if (this.needsSort) {\r\n            this.sort();\r\n        }\r\n        let index = 0;\r\n        for (; index < this.sortedConnectedValues.length; index++) {\r\n            callback(this.sortedConnectedValues[index], index);\r\n        }\r\n        Reflect.ownKeys(this.isolatedVertices).forEach((key) => {\r\n            const vertex = this.isolatedVertices[key];\r\n            if (vertex.value !== undefined)\r\n                callback(vertex.value, index++);\r\n        });\r\n    }\r\n    getValueByKey(key) {\r\n        return this.allVertices[key]?.value;\r\n    }\r\n    getKeyByValue(value) {\r\n        return (Reflect.ownKeys(this.connectedVertices).find((key) => this.connectedVertices[key].value === value) ??\r\n            Reflect.ownKeys(this.isolatedVertices).find((key) => this.isolatedVertices[key].value === value));\r\n    }\r\n    sort() {\r\n        const inDegree = new Map();\r\n        const zeroInDegreeQueue = [];\r\n        const result = [];\r\n        // we're only interested in vertices that have a value\r\n        const connectedVertexKeysWithValues = Reflect.ownKeys(this.connectedVertices).filter((key) => {\r\n            const vertex = this.connectedVertices[key];\r\n            return vertex.value !== undefined;\r\n        });\r\n        // Initialize inDegree (count of incoming edges) for each vertex\r\n        connectedVertexKeysWithValues.forEach((vertex) => {\r\n            inDegree.set(vertex, 0);\r\n        });\r\n        // Calculate inDegree for each vertex\r\n        connectedVertexKeysWithValues.forEach((vertexKey) => {\r\n            const vertex = this.connectedVertices[vertexKey];\r\n            vertex.next.forEach((next) => {\r\n                // check if \"next\" vertex has a value\r\n                const nextVertex = this.connectedVertices[next];\r\n                if (!nextVertex)\r\n                    return;\r\n                inDegree.set(next, (inDegree.get(next) || 0) + 1);\r\n            });\r\n        });\r\n        // Enqueue vertices with inDegree 0\r\n        inDegree.forEach((degree, value) => {\r\n            if (degree === 0) {\r\n                zeroInDegreeQueue.push(value);\r\n            }\r\n        });\r\n        // Process vertices with inDegree 0 and decrease inDegree of adjacent vertices\r\n        while (zeroInDegreeQueue.length > 0) {\r\n            const vertexKey = zeroInDegreeQueue.shift();\r\n            result.push(vertexKey);\r\n            const v = connectedVertexKeysWithValues.find((key) => key === vertexKey);\r\n            if (v) {\r\n                this.connectedVertices[v]?.next.forEach((adjVertex) => {\r\n                    const adjVertexInDegree = (inDegree.get(adjVertex) || 0) - 1;\r\n                    inDegree.set(adjVertex, adjVertexInDegree);\r\n                    if (adjVertexInDegree === 0) {\r\n                        zeroInDegreeQueue.push(adjVertex);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        // Check for cycles in the graph\r\n        if (result.length !== connectedVertexKeysWithValues.length) {\r\n            throw new Error('The graph contains a cycle, and thus can not be sorted topologically.');\r\n        }\r\n        const filterUndefined = (value) => value !== undefined;\r\n        this.sortedConnectedValues = result\r\n            .map((key) => this.connectedVertices[key].value)\r\n            .filter(filterUndefined);\r\n        this.needsSort = false;\r\n    }\r\n    clear() {\r\n        this.allVertices = {};\r\n        this.isolatedVertices = {};\r\n        this.connectedVertices = {};\r\n        this.sortedConnectedValues = [];\r\n        this.needsSort = false;\r\n    }\r\n    static isKey(value) {\r\n        return typeof value === 'string' || typeof value === 'symbol';\r\n    }\r\n    static isValue(value) {\r\n        return typeof value === 'object' && 'key' in value;\r\n    }\r\n}\r\n", "export class Task {\r\n    key;\r\n    stage;\r\n    callback;\r\n    runTask = true;\r\n    stop() {\r\n        this.runTask = false;\r\n    }\r\n    start() {\r\n        this.runTask = true;\r\n    }\r\n    constructor(stage, key, callback) {\r\n        this.stage = stage;\r\n        this.key = key;\r\n        this.callback = callback;\r\n    }\r\n    run(delta) {\r\n        if (!this.runTask)\r\n            return;\r\n        this.callback(delta);\r\n    }\r\n}\r\n", "import { DAG } from './DAG';\r\nimport { Task } from './Task';\r\n/**\r\n * A Stage is a collection of steps. The steps are run in a topological sort\r\n * order.\r\n */\r\nexport class Stage extends DAG {\r\n    key;\r\n    scheduler;\r\n    get tasks() {\r\n        return this.sortedVertices;\r\n    }\r\n    callback = (_, r) => r();\r\n    constructor(scheduler, key, callback) {\r\n        super();\r\n        this.scheduler = scheduler;\r\n        this.key = key;\r\n        if (callback)\r\n            this.callback = callback.bind(this);\r\n    }\r\n    createTask(key, callback, options) {\r\n        const task = new Task(this, key, callback);\r\n        this.add(key, task, options);\r\n        return task;\r\n    }\r\n    getTask(key) {\r\n        return this.getValueByKey(key);\r\n    }\r\n    removeTask = this.remove.bind(this);\r\n    run(delta) {\r\n        this.callback(delta, (deltaOverride) => {\r\n            this.forEachNode((task) => {\r\n                task.run(deltaOverride ?? delta);\r\n            });\r\n        });\r\n    }\r\n    runWithTiming(delta) {\r\n        const taskTimings = {};\r\n        this.callback(delta, (deltaOverride) => {\r\n            this.forEachNode((task) => {\r\n                const start = performance.now();\r\n                task.run(deltaOverride ?? delta);\r\n                const duration = performance.now() - start;\r\n                taskTimings[task.key] = duration;\r\n            });\r\n        });\r\n        return taskTimings;\r\n    }\r\n    getSchedule() {\r\n        return this.mapNodes((l) => l.key.toString());\r\n    }\r\n}\r\n", "import { DAG } from './DAG';\r\nimport { Stage } from './Stage';\r\n/**\r\n * A Scheduler is responsible for running stages. It runs the stages in a\r\n * requestAnimationFrame stage.\r\n */\r\nexport class Scheduler extends DAG {\r\n    lastTime = performance.now();\r\n    clampDeltaTo = 0.1;\r\n    get stages() {\r\n        return this.sortedVertices;\r\n    }\r\n    constructor(options) {\r\n        super();\r\n        if (options?.clampDeltaTo)\r\n            this.clampDeltaTo = options.clampDeltaTo;\r\n        this.run = this.run.bind(this);\r\n    }\r\n    createStage(key, options) {\r\n        const stage = new Stage(this, key, options?.callback);\r\n        this.add(key, stage, {\r\n            after: options?.after,\r\n            before: options?.before\r\n        });\r\n        return stage;\r\n    }\r\n    getStage(key) {\r\n        return this.getValueByKey(key);\r\n    }\r\n    removeStage = this.remove.bind(this);\r\n    /**\r\n     * Runs all the stages in the scheduler.\r\n     *\r\n     * @param time The time in milliseconds since the start of the program.\r\n     */\r\n    run(time) {\r\n        const delta = time - this.lastTime;\r\n        this.forEachNode((stage) => {\r\n            // we pass the delta as seconds, not milliseconds,\r\n            // this is in line with how Three.js, Unity and\r\n            // other game engines do it. On top of that, it\r\n            // needs to be clamped to prevent large delta\r\n            // values from causing large jumps in the game\r\n            // state.\r\n            stage.run(Math.min(delta / 1000, this.clampDeltaTo));\r\n        });\r\n        this.lastTime = time;\r\n    }\r\n    runWithTiming(time) {\r\n        const delta = time - this.lastTime;\r\n        const stageTimings = {};\r\n        const start = performance.now();\r\n        this.forEachNode((stage) => {\r\n            const start = performance.now();\r\n            const taskTimings = stage.runWithTiming(Math.min(delta / 1000, this.clampDeltaTo));\r\n            const duration = performance.now() - start;\r\n            stageTimings[stage.key.toString()] = {\r\n                duration,\r\n                tasks: taskTimings\r\n            };\r\n        });\r\n        return {\r\n            total: performance.now() - start,\r\n            stages: stageTimings\r\n        };\r\n    }\r\n    getSchedule(include = {\r\n        tasks: true\r\n    }) {\r\n        return {\r\n            stages: this.mapNodes((stage) => {\r\n                if (stage === undefined)\r\n                    throw new Error('Stage not found');\r\n                return {\r\n                    key: stage.key.toString(),\r\n                    ...{ tasks: include.tasks ? stage.getSchedule() : undefined }\r\n                };\r\n            })\r\n        };\r\n    }\r\n    dispose() {\r\n        this.clear();\r\n    }\r\n}\r\n", "import { onDestroy } from 'svelte';\r\nimport { derived, writable } from 'svelte/store';\r\n/**\r\n * ### `watch`\r\n *\r\n * Watch a single store or multiple stores and call a callback when they change to trigger side effects.\r\n * The callback can return a cleanup function that will be called when the stores change again or when the component is destroyed.\r\n *\r\n * ```ts\r\n * const store = writable(0)\r\n *\r\n * watch(store, (value) => {\r\n * \tconsole.log(value) // 0\r\n * })\r\n * ```\r\n *\r\n * You can also watch multiple stores:\r\n *\r\n * ```ts\r\n * const store1 = writable(0)\r\n * const store2 = writable(1)\r\n *\r\n * watch([store1, store2], ([value1, value2]) => {\r\n * \tconsole.log(value1, value2) // 0 1\r\n * })\r\n * ```\r\n *\r\n * The callback can return a cleanup function that will be called when the stores change again or when the component is destroyed.\r\n *\r\n * ```ts\r\n * const store = writable(0)\r\n *\r\n * watch(store, (value) => {\r\n * \tconsole.log(value) // 0\r\n * \treturn () => {\r\n * \t\tconsole.log('cleanup')\r\n * \t}\r\n * })\r\n * ```\r\n *\r\n * @param stores\r\n * @param callback\r\n */\r\nexport const watch = (stores, callback) => {\r\n    const d = derived(stores, (values) => {\r\n        return values;\r\n    });\r\n    let cleanupFn;\r\n    const unsubscribe = d.subscribe(async (values) => {\r\n        if (cleanupFn)\r\n            cleanupFn();\r\n        const fn = await callback(values);\r\n        if (fn)\r\n            cleanupFn = fn;\r\n    });\r\n    onDestroy(() => {\r\n        unsubscribe();\r\n        if (cleanupFn)\r\n            cleanupFn();\r\n    });\r\n};\r\nexport function memoize(stores, transform) {\r\n    const obj = {\r\n        current: undefined\r\n    };\r\n    watch(stores, (v) => {\r\n        obj.current = transform ? transform(v) : v;\r\n    });\r\n    return obj;\r\n}\r\n/**\r\n * ### `currentWritable`\r\n *\r\n * A writable store that also has a `current` property that is updated synchronously.\r\n * For use in non-reactive contexts e.g. loops where unwrapping a store every frame is expensive.\r\n *\r\n * ```ts\r\n * const store = currentWritable(0)\r\n *\r\n * useTask(() => {\r\n * \tconsole.log(store.current) // 0\r\n * })\r\n *\r\n * @param value\r\n * @returns\r\n */\r\nexport const currentWritable = (value) => {\r\n    const store = writable(value);\r\n    const extendedWritable = {\r\n        set: (value) => {\r\n            extendedWritable.current = value;\r\n            store.set(value);\r\n        },\r\n        subscribe: store.subscribe,\r\n        update: (fn) => {\r\n            const newValue = fn(extendedWritable.current);\r\n            extendedWritable.current = newValue;\r\n            store.set(newValue);\r\n        },\r\n        current: value\r\n    };\r\n    return extendedWritable;\r\n};\r\n", "import { PerspectiveCamera } from 'three';\r\nimport { watch } from './storeUtils';\r\nconst defaultCamera = new PerspectiveCamera(75, 0, 0.1, 1000);\r\ndefaultCamera.position.z = 5;\r\ndefaultCamera.lookAt(0, 0, 0);\r\nexport const getDefaultCamera = () => defaultCamera;\r\nexport const setDefaultCameraAspectOnSizeChange = (ctx) => {\r\n    watch(ctx.size, (size) => {\r\n        if (ctx.camera.current === defaultCamera) {\r\n            const cam = ctx.camera.current;\r\n            cam.aspect = size.width / size.height;\r\n            cam.updateProjectionMatrix();\r\n            ctx.invalidate();\r\n        }\r\n    });\r\n};\r\n", "import { getContext, setContext } from 'svelte';\r\nexport const orderToKey = (order) => `useFrame-order-${order.toString()}`;\r\nconst useLegacyFrameCompatibilityContextKey = Symbol('use-legacy-frame-compatibility-context');\r\nexport const injectLegacyFrameCompatibilityContext = () => {\r\n    const ctx = {\r\n        useFrameOrders: [],\r\n        useRenderOrders: []\r\n    };\r\n    setContext(useLegacyFrameCompatibilityContextKey, ctx);\r\n    return ctx;\r\n};\r\nexport const useLegacyFrameCompatibilityContext = () => {\r\n    const ctx = getContext(useLegacyFrameCompatibilityContextKey);\r\n    if (ctx === undefined) {\r\n        throw new Error('No legacy frame compatibility context found, are you using this hook inside of <Canvas>?');\r\n    }\r\n    return ctx;\r\n};\r\n", "import { setContext, tick } from 'svelte';\r\nimport { derived } from 'svelte/store';\r\nimport { Scene } from 'three';\r\nimport { Scheduler } from '../frame-scheduling';\r\nimport { getDefaultCamera, setDefaultCameraAspectOnSizeChange } from './defaultCamera';\r\nimport { currentWritable } from './storeUtils';\r\nimport { injectLegacyFrameCompatibilityContext } from '../hooks/legacy/utils';\r\n/**\r\n * This function creates the necessary context objects for a Threlte application.\r\n */\r\nexport const createThrelteContext = (options) => {\r\n    const internalCtx = {\r\n        frameInvalidated: true,\r\n        advance: false,\r\n        autoInvalidations: new Set(),\r\n        resetFrameInvalidation: () => {\r\n            internalCtx.frameInvalidated = false;\r\n            internalCtx.advance = false;\r\n        },\r\n        dispose: async (force = false) => {\r\n            await tick();\r\n            if (!internalCtx.shouldDispose && !force)\r\n                return;\r\n            internalCtx.disposableObjects.forEach((mounted, object) => {\r\n                if (mounted === 0 || force) {\r\n                    object?.dispose?.();\r\n                    internalCtx.disposableObjects.delete(object);\r\n                }\r\n            });\r\n            internalCtx.shouldDispose = false;\r\n        },\r\n        collectDisposableObjects: (object, objects) => {\r\n            const disposables = objects ?? [];\r\n            if (!object)\r\n                return disposables;\r\n            // Scenes can't be disposed\r\n            if (object?.dispose && typeof object.dispose === 'function' && object.type !== 'Scene') {\r\n                disposables.push(object);\r\n            }\r\n            // iterate over properties of object\r\n            Object.entries(object).forEach(([propKey, propValue]) => {\r\n                // we don't want to dispose the parent, we can skip \"children\"\r\n                if (propKey === 'parent' || propKey === 'children' || typeof propValue !== 'object')\r\n                    return;\r\n                const value = propValue;\r\n                if (value?.dispose) {\r\n                    internalCtx.collectDisposableObjects(value, disposables);\r\n                }\r\n            });\r\n            return disposables;\r\n        },\r\n        addDisposableObjects: (objects) => {\r\n            objects.forEach((obj) => {\r\n                const currentValue = internalCtx.disposableObjects.get(obj);\r\n                if (currentValue) {\r\n                    internalCtx.disposableObjects.set(obj, currentValue + 1);\r\n                }\r\n                else {\r\n                    internalCtx.disposableObjects.set(obj, 1);\r\n                }\r\n            });\r\n        },\r\n        removeDisposableObjects: (objects) => {\r\n            if (objects.length === 0)\r\n                return;\r\n            objects.forEach((obj) => {\r\n                const currentValue = internalCtx.disposableObjects.get(obj);\r\n                if (currentValue && currentValue > 0) {\r\n                    internalCtx.disposableObjects.set(obj, currentValue - 1);\r\n                }\r\n            });\r\n            internalCtx.shouldDispose = true;\r\n        },\r\n        disposableObjects: new Map(),\r\n        shouldDispose: false\r\n    };\r\n    // TODO: Remove in Threlte 7\r\n    const { useRenderOrders } = injectLegacyFrameCompatibilityContext();\r\n    const scheduler = new Scheduler();\r\n    const mainStage = scheduler.createStage(Symbol('threlte-main-stage'));\r\n    const renderStage = scheduler.createStage(Symbol('threlte-render-stage'), {\r\n        after: mainStage,\r\n        callback(_, runTasks) {\r\n            if (ctx.shouldRender())\r\n                runTasks();\r\n        }\r\n    });\r\n    const autoRenderTask = renderStage.createTask(Symbol('threlte-auto-render-task'), (_) => {\r\n        // we're in here when autoRender is true In Threlte 7 we still have to\r\n        // check for the existence of `useRender` instances\r\n        if (useRenderOrders.length > 0)\r\n            return;\r\n        // if there are no useRender instances, we can render the scene\r\n        ctx.renderer.render(ctx.scene, ctx.camera.current);\r\n    });\r\n    const ctx = {\r\n        size: derived([options.userSize, options.parentSize], ([uSize, pSize]) => {\r\n            return uSize ? uSize : pSize;\r\n        }),\r\n        camera: currentWritable(getDefaultCamera()),\r\n        scene: new Scene(),\r\n        renderer: undefined,\r\n        invalidate: () => {\r\n            internalCtx.frameInvalidated = true;\r\n        },\r\n        advance: () => {\r\n            internalCtx.advance = true;\r\n        },\r\n        colorSpace: currentWritable(options.colorSpace),\r\n        toneMapping: currentWritable(options.toneMapping),\r\n        dpr: currentWritable(options.dpr),\r\n        useLegacyLights: currentWritable(options.useLegacyLights),\r\n        shadows: currentWritable(options.shadows),\r\n        colorManagementEnabled: currentWritable(options.colorManagementEnabled),\r\n        renderMode: currentWritable(options.renderMode),\r\n        autoRender: currentWritable(options.autoRender),\r\n        scheduler,\r\n        mainStage,\r\n        renderStage,\r\n        autoRenderTask,\r\n        shouldRender: () => {\r\n            const shouldRender = ctx.renderMode.current === 'always' ||\r\n                (ctx.renderMode.current === 'on-demand' &&\r\n                    (internalCtx.frameInvalidated || internalCtx.autoInvalidations.size > 0)) ||\r\n                (ctx.renderMode.current === 'manual' && internalCtx.advance);\r\n            return shouldRender;\r\n        }\r\n    };\r\n    setDefaultCameraAspectOnSizeChange(ctx);\r\n    const userCtx = currentWritable({});\r\n    setContext('threlte', ctx);\r\n    setContext('threlte-internal-context', internalCtx);\r\n    setContext('threlte-user-context', userCtx);\r\n    return ctx;\r\n};\r\n", "export const browser = typeof window !== 'undefined';\r\n", "import { onDestroy } from 'svelte';\r\nimport { currentWritable } from '../lib/storeUtils';\r\nimport { browser } from '../lib/browser';\r\nexport const useParentSize = () => {\r\n    const parentSize = currentWritable({ width: 0, height: 0 });\r\n    if (!browser) {\r\n        return {\r\n            parentSize,\r\n            parentSizeAction: () => {\r\n                /* do nothing */\r\n            }\r\n        };\r\n    }\r\n    // Only observe childList changes of the parent\r\n    const mutationOptions = { childList: true, subtree: false, attributes: false };\r\n    let el;\r\n    const observeParent = (parent) => {\r\n        resizeObserver.disconnect();\r\n        mutationObserver.disconnect();\r\n        resizeObserver.observe(parent);\r\n        mutationObserver.observe(parent, mutationOptions);\r\n    };\r\n    // The canvas should match the contentRect of its parent\r\n    const resizeObserver = new ResizeObserver(([entry]) => {\r\n        const { width, height } = entry.contentRect;\r\n        if (width === parentSize.current.width && height === parentSize.current.height)\r\n            return;\r\n        parentSize.set({ width, height });\r\n    });\r\n    // Use a mutation observer to detect reparenting\r\n    const mutationObserver = new MutationObserver((mutationsList) => {\r\n        for (const mutation of mutationsList) {\r\n            for (const node of mutation.removedNodes) {\r\n                if (el === node && el.parentElement) {\r\n                    observeParent(el.parentElement);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    });\r\n    const parentSizeAction = (node) => {\r\n        el = node;\r\n        const parent = el.parentElement;\r\n        if (!parent)\r\n            return;\r\n        parentSize.set({\r\n            width: parent.clientWidth,\r\n            height: parent.clientHeight\r\n        });\r\n        observeParent(parent);\r\n    };\r\n    onDestroy(() => {\r\n        resizeObserver.disconnect();\r\n        mutationObserver.disconnect();\r\n    });\r\n    return {\r\n        parentSize,\r\n        parentSizeAction\r\n    };\r\n};\r\n", "import { onDestroy } from 'svelte';\r\nimport { writable } from 'svelte/store';\r\nexport function createObjectStore(object, onChange) {\r\n    const objectStore = writable(object);\r\n    let unwrappedObject = object;\r\n    const unsubscribeObjectStore = objectStore.subscribe((o) => (unwrappedObject = o));\r\n    onDestroy(unsubscribeObjectStore);\r\n    const set = (newObject) => {\r\n        if (newObject?.uuid === unwrappedObject?.uuid)\r\n            return;\r\n        const oldObject = unwrappedObject;\r\n        objectStore.set(newObject);\r\n        onChange?.(newObject, oldObject);\r\n    };\r\n    const update = (callback) => {\r\n        const newObject = callback(unwrappedObject);\r\n        if (newObject?.uuid === unwrappedObject?.uuid)\r\n            return;\r\n        const oldObject = unwrappedObject;\r\n        objectStore.set(newObject);\r\n        onChange?.(newObject, oldObject);\r\n    };\r\n    return {\r\n        ...objectStore,\r\n        set,\r\n        update\r\n    };\r\n}\r\n", "import { getContext } from 'svelte';\r\nexport const useThrelte = () => {\r\n    const context = getContext('threlte');\r\n    if (context === undefined) {\r\n        throw new Error('No Threlte context found, are you using this hook inside of <Canvas>?');\r\n    }\r\n    return context;\r\n};\r\n", "import { getContext, setContext } from 'svelte';\r\nimport { createObjectStore } from '../lib/createObjectStore';\r\nconst key = Symbol('threlte-hierarchical-parent-context');\r\nexport const useParent = () => {\r\n    return getContext(key);\r\n};\r\nexport const setParent = (context) => {\r\n    return setContext(key, context);\r\n};\r\nexport const createParentContext = (ref) => {\r\n    const context = createObjectStore(ref);\r\n    setContext(key, context);\r\n    return context;\r\n};\r\n", null, null, "/**\r\n * @file This file contains the cache implementation for Threlte. The cache is\r\n * used to cache the return value of a promise based on the provided keys.\r\n */\r\nimport { getContext, setContext } from 'svelte';\r\nexport const shallowEqualArrays = (arrA, arrB) => {\r\n    if (arrA === arrB)\r\n        return true;\r\n    if (!arrA || !arrB)\r\n        return false;\r\n    const len = arrA.length;\r\n    if (arrB.length !== len)\r\n        return false;\r\n    for (let i = 0; i < len; i++)\r\n        if (arrA[i] !== arrB[i])\r\n            return false;\r\n    return true;\r\n};\r\n/**\r\n * ### `createCache`\r\n *\r\n * Every Threlte application has its own cache. This prevents models from being\r\n * shared between applications because e.g. THREE.Mesh objects cannot be mounted\r\n * in multiple scenes.\r\n */\r\nexport const createCache = () => {\r\n    setContext('threlte-cache', []);\r\n};\r\n/**\r\n * ### `useCache`\r\n *\r\n * This hook is used to access the cache. It returns a `remember` function that\r\n * can be used to cache a promise based on the provided keys. The `remember`\r\n * function will return the cached value if the promise has already been\r\n * resolved and the keys match.\r\n *\r\n * @example\r\n * ```ts\r\n * const { remember } = useCache()\r\n *\r\n * const asnycWritable = remember(async () => {\r\n *  const loader = new GLTFLoader()\r\n *  const { scene } = await loader.loadAsync('/path/to/model.glb')\r\n *  return scene\r\n * })\r\n * ```\r\n *\r\n * The model will only be loaded once, even if `remember` is invoked multiple\r\n * times with the same keys.\r\n *\r\n * The `clear` function can be used to clear the cache for a specific set of keys.\r\n */\r\nexport const useCache = () => {\r\n    const cache = getContext('threlte-cache');\r\n    if (!cache) {\r\n        throw new Error('No cache found. The cache can only be used in a child component to <Canvas>.');\r\n    }\r\n    const remember = (callback, keys) => {\r\n        for (const entry of cache) {\r\n            // Find a match\r\n            if (shallowEqualArrays(keys, entry.keys)) {\r\n                // If an error occurred, throw\r\n                if (entry.error)\r\n                    throw entry.error;\r\n                // If a response is pending, return\r\n                if (entry.promise)\r\n                    return entry.promise;\r\n            }\r\n        }\r\n        // If no match was found, create a new entry\r\n        const entry = {\r\n            promise: callback(),\r\n            keys,\r\n            value: undefined\r\n        };\r\n        // Add the entry to the cache\r\n        cache.push(entry);\r\n        // Add a catch handler to the promise\r\n        entry.promise.catch((error) => {\r\n            // store the error\r\n            entry.error = error;\r\n            // we don't throw here\r\n        });\r\n        // Return the promise\r\n        return entry.promise;\r\n    };\r\n    const clear = (keys) => {\r\n        const index = cache.findIndex((entry) => shallowEqualArrays(keys, entry.keys));\r\n        if (index !== -1) {\r\n            cache.splice(index, 1);\r\n        }\r\n    };\r\n    return {\r\n        remember,\r\n        clear\r\n    };\r\n};\r\n", "import { REVISION } from 'three';\r\n// REVISION can be '{number}' or '{number}dev'\r\nconst normalizedRevision = REVISION.replace('dev', '');\r\n/**\r\n * The current Three.js revision.\r\n */\r\nexport const revision = Number.parseInt(normalizedRevision);\r\n", "import { writable } from 'svelte/store';\r\nimport { ColorManagement, PCFSoftShadowMap, WebGLRenderer } from 'three';\r\nimport { watch } from './storeUtils';\r\n/**\r\n * ### `useRenderer`\r\n *\r\n * This hook creates a renderer and listens to changes in the context to\r\n * update the renderer accordingly.\r\n *\r\n * It listens to the following context properties:\r\n * - `colorManagementEnabled`\r\n * - `colorSpace`\r\n * - `dpr`\r\n * - `size`\r\n * - `shadows`\r\n * - `toneMapping`\r\n * - `useLegacyLights`\r\n */\r\nexport const useRenderer = (ctx) => {\r\n    const renderer = writable(undefined);\r\n    const createRenderer = (canvas, rendererParameters) => {\r\n        ctx.renderer = new WebGLRenderer({\r\n            powerPreference: 'high-performance',\r\n            canvas,\r\n            antialias: true,\r\n            alpha: true,\r\n            ...rendererParameters\r\n        });\r\n        renderer.set(ctx.renderer);\r\n    };\r\n    watch([ctx.colorManagementEnabled], ([colorManagementEnabled]) => {\r\n        ColorManagement.enabled = colorManagementEnabled;\r\n    });\r\n    watch([renderer, ctx.colorSpace], ([renderer, colorSpace]) => {\r\n        if (!renderer)\r\n            return;\r\n        renderer.outputColorSpace = colorSpace;\r\n    });\r\n    watch([renderer, ctx.dpr], ([renderer, dpr]) => {\r\n        renderer?.setPixelRatio(dpr);\r\n    });\r\n    watch([renderer, ctx.size], ([renderer, size]) => {\r\n        if (renderer?.xr?.isPresenting)\r\n            return;\r\n        renderer?.setSize(size.width, size.height);\r\n    });\r\n    watch([renderer, ctx.shadows], ([renderer, shadows]) => {\r\n        if (!renderer)\r\n            return;\r\n        renderer.shadowMap.enabled = !!shadows;\r\n        if (shadows && shadows !== true) {\r\n            renderer.shadowMap.type = shadows;\r\n        }\r\n        else if (shadows === true) {\r\n            renderer.shadowMap.type = PCFSoftShadowMap;\r\n        }\r\n    });\r\n    watch([renderer, ctx.toneMapping], ([renderer, toneMapping]) => {\r\n        if (!renderer)\r\n            return;\r\n        renderer.toneMapping = toneMapping;\r\n    });\r\n    watch([renderer, ctx.useLegacyLights], ([renderer, useLegacyLights]) => {\r\n        if (!renderer)\r\n            return;\r\n        if (useLegacyLights) {\r\n            renderer.useLegacyLights = useLegacyLights;\r\n        }\r\n    });\r\n    return {\r\n        createRenderer\r\n    };\r\n};\r\n", "import { getContext } from 'svelte';\r\nexport const useThrelteInternal = () => {\r\n    return getContext('threlte-internal-context');\r\n};\r\n", null, null, "const classRegex = /^\\s*class\\s+/;\r\n// Type Guards\r\nconst isClass = (input) => {\r\n    if (typeof input !== 'function') {\r\n        return false;\r\n    }\r\n    return classRegex.test(input.toString());\r\n};\r\nconst argsIsConstructorParameters = (args) => {\r\n    return Array.isArray(args);\r\n};\r\nexport const determineRef = (is, args) => {\r\n    if (isClass(is)) {\r\n        if (argsIsConstructorParameters(args)) {\r\n            return new is(...args);\r\n        }\r\n        else {\r\n            return new is();\r\n        }\r\n    }\r\n    return is;\r\n};\r\nexport const extendsObject3D = (object) => {\r\n    return 'isObject3D' in object;\r\n};\r\nexport const isDisposableObject = (object) => {\r\n    return 'dispose' in object;\r\n};\r\n", "/**\r\n * ### `resolvePropertyPath`\r\n *\r\n * Threlte supports props called \"pierced props\" that allow you to set\r\n * properties on nested objects. This function resolves a property path to a\r\n * target object and the property key. The property path can include dots to indicate\r\n * nested objects.\r\n *\r\n * ```svelte\r\n * <T.PerspectiveCamera position.x={10} />\r\n * ```\r\n *\r\n * … resolves to …\r\n *\r\n * ```ts\r\n * const { target, key } = resolvePropertyPath(camera, 'position.x')\r\n * target[key] = 10\r\n * ```\r\n */\r\nexport const resolvePropertyPath = (target, propertyPath) => {\r\n    if (propertyPath.includes('.')) {\r\n        const path = propertyPath.split('.');\r\n        const key = path.pop();\r\n        for (let i = 0; i < path.length; i += 1) {\r\n            target = target[path[i]];\r\n        }\r\n        return {\r\n            target,\r\n            key\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            target,\r\n            key: propertyPath\r\n        };\r\n    }\r\n};\r\n", "import { onDestroy } from 'svelte';\r\nimport { useThrelte } from '../../../hooks/useThrelte';\r\nimport { resolvePropertyPath } from './resolvePropertyPath';\r\nconst initialValueBeforeAttach = Symbol('initialValueBeforeAttach');\r\nexport const useAttach = () => {\r\n    const { invalidate } = useThrelte();\r\n    let isAttached = false;\r\n    let valueBeforeAttach = initialValueBeforeAttach;\r\n    let detachFn;\r\n    // the target that the object is attached to\r\n    let attachedTo;\r\n    // the property name that the object is attached to\r\n    let attachedKey;\r\n    const update = (instance, parent, attach) => {\r\n        detach();\r\n        // maybe assign 'material' or 'geometry' automatically if not specified\r\n        if (!attach) {\r\n            const i = instance;\r\n            const isMaterial = i?.isMaterial || false;\r\n            if (isMaterial) {\r\n                attach = 'material';\r\n            }\r\n            const isGeometry = i?.isBufferGeometry || i?.isGeometry || false;\r\n            if (isGeometry) {\r\n                attach = 'geometry';\r\n            }\r\n        }\r\n        if (!attach)\r\n            return;\r\n        if (typeof attach === 'function') {\r\n            detachFn = attach(parent, instance);\r\n        }\r\n        else {\r\n            const { target, key } = resolvePropertyPath(parent, attach);\r\n            valueBeforeAttach = target[key];\r\n            target[key] = instance;\r\n            attachedTo = target;\r\n            attachedKey = key;\r\n        }\r\n        isAttached = true;\r\n        invalidate();\r\n    };\r\n    const detach = () => {\r\n        if (!isAttached)\r\n            return;\r\n        if (detachFn) {\r\n            detachFn();\r\n            detachFn = undefined;\r\n        }\r\n        else if (attachedTo && attachedKey && valueBeforeAttach !== initialValueBeforeAttach) {\r\n            attachedTo[attachedKey] = valueBeforeAttach;\r\n            valueBeforeAttach = initialValueBeforeAttach;\r\n            attachedTo = undefined;\r\n            attachedKey = undefined;\r\n        }\r\n        isAttached = false;\r\n        invalidate();\r\n    };\r\n    onDestroy(() => {\r\n        detach();\r\n    });\r\n    return {\r\n        update\r\n    };\r\n};\r\n", "import { onDestroy } from 'svelte';\r\nimport { useThrelte } from '../../../hooks/useThrelte';\r\nconst isCamera = (value) => {\r\n    return value && value.isCamera;\r\n};\r\nconst isOrthographicCamera = (value) => {\r\n    return value && value.isOrthographicCamera;\r\n};\r\nconst isPerspectiveCamera = (value) => {\r\n    return value && value.isPerspectiveCamera;\r\n};\r\nconst isPerspectiveCameraOrOrthographicCamera = (value) => {\r\n    return isPerspectiveCamera(value) || isOrthographicCamera(value);\r\n};\r\nexport const useCamera = () => {\r\n    const { invalidate, size, camera } = useThrelte();\r\n    let currentInstance;\r\n    let unsubscribe = undefined;\r\n    onDestroy(() => {\r\n        unsubscribe?.();\r\n    });\r\n    const subscriber = (size) => {\r\n        if (!currentInstance)\r\n            return;\r\n        if (isOrthographicCamera(currentInstance)) {\r\n            currentInstance.left = size.width / -2;\r\n            currentInstance.right = size.width / 2;\r\n            currentInstance.top = size.height / 2;\r\n            currentInstance.bottom = size.height / -2;\r\n            currentInstance.updateProjectionMatrix();\r\n            currentInstance.updateMatrixWorld();\r\n            invalidate();\r\n        }\r\n        else if (isPerspectiveCamera(currentInstance)) {\r\n            currentInstance.aspect = size.width / size.height;\r\n            currentInstance.updateProjectionMatrix();\r\n            currentInstance.updateMatrixWorld();\r\n            invalidate();\r\n        }\r\n    };\r\n    const update = (instance, manual) => {\r\n        unsubscribe?.();\r\n        if (manual || !isPerspectiveCameraOrOrthographicCamera(instance)) {\r\n            currentInstance = undefined;\r\n            return;\r\n        }\r\n        currentInstance = instance;\r\n        unsubscribe = size.subscribe(subscriber);\r\n    };\r\n    const makeDefaultCamera = (instance, makeDefault) => {\r\n        if (!isCamera(instance) || !makeDefault)\r\n            return;\r\n        camera.set(instance);\r\n        invalidate();\r\n    };\r\n    return {\r\n        update,\r\n        makeDefaultCamera\r\n    };\r\n};\r\n", "import { get_current_component } from 'svelte/internal';\r\n/**\r\n * ### `createRawEventDispatcher`\r\n *\r\n * This event dispatcher creates raw events unlike Svelte's own event dispatcher\r\n * which nests the data in a detail object (`CustomEvent<Payload>`). This is not\r\n * nesessary for a lot of Threlte use cases and makes it harder to work with the payload.\r\n *\r\n * @example\r\n *\r\n * ComponentA.svelte:\r\n * ```svelte\r\n * <script>\r\n * \tconst dispatch = createRawEventDispatcher<{ foo: string }>()\r\n * \tdispatch('foo', 'bar')\r\n * </script>\r\n * ```\r\n *\r\n * ComponentB.svelte:\r\n * ```svelte\r\n * <ComponentA on:foo={(e) => console.log(e)} /> <!-- 'bar' -->\r\n * ```\r\n */\r\nexport const createRawEventDispatcher = () => {\r\n    const component = get_current_component();\r\n    const dispatchRawEvent = (type, value) => {\r\n        const callbacks = component.$$.callbacks[type];\r\n        if (callbacks) {\r\n            callbacks.forEach((fn) => {\r\n                fn(value);\r\n            });\r\n        }\r\n    };\r\n    const hasEventListener = (type) => {\r\n        return Boolean(component.$$.callbacks[type]);\r\n    };\r\n    Object.defineProperty(dispatchRawEvent, 'hasEventListener', {\r\n        value: hasEventListener,\r\n        enumerable: true\r\n    });\r\n    return dispatchRawEvent;\r\n};\r\n", "import { onDestroy, onMount } from 'svelte';\r\nimport { createRawEventDispatcher } from '../../../lib/createRawEventDispatcher';\r\nexport const useCreateEvent = () => {\r\n    const dispatchRaw = createRawEventDispatcher();\r\n    const cleanupFunctions = [];\r\n    let ref = undefined;\r\n    let mounted = false;\r\n    const dispatchCreateEvent = () => {\r\n        // call every cleanup function\r\n        cleanupFunctions.forEach((cleanup) => cleanup());\r\n        // clear the cleanup functions array\r\n        cleanupFunctions.length = 0;\r\n        const cleanup = (callback) => {\r\n            // add cleanup function to array\r\n            cleanupFunctions.push(callback);\r\n        };\r\n        dispatchRaw('create', { ref, cleanup });\r\n    };\r\n    const updateRef = (newRef) => {\r\n        ref = newRef;\r\n        if (!mounted)\r\n            return;\r\n        dispatchCreateEvent();\r\n    };\r\n    onMount(() => {\r\n        dispatchCreateEvent();\r\n        mounted = true;\r\n    });\r\n    onDestroy(() => {\r\n        // call every cleanup function\r\n        cleanupFunctions.forEach((cleanup) => cleanup());\r\n    });\r\n    return {\r\n        updateRef\r\n    };\r\n};\r\n", "import { onMount } from 'svelte';\r\nimport { get_current_component } from 'svelte/internal';\r\nimport { writable } from 'svelte/store';\r\nimport { createRawEventDispatcher } from '../../../lib/createRawEventDispatcher';\r\nimport { watch } from '../../../lib/storeUtils';\r\n/**\r\n * Typeguard to check if a value is extending THREE.EventDispatcher\r\n * @param value\r\n * @returns\r\n */\r\nconst isEventDispatcher = (value) => {\r\n    return !!value?.addEventListener;\r\n};\r\nexport const useEvents = () => {\r\n    const dispatch = createRawEventDispatcher();\r\n    const component = get_current_component();\r\n    const eventHandlerProxy = (event) => {\r\n        if (event?.type) {\r\n            dispatch(event.type, event);\r\n        }\r\n    };\r\n    const cleanupEventListeners = (ref, events) => {\r\n        if (isEventDispatcher(ref)) {\r\n            events.forEach((eventName) => {\r\n                ref.removeEventListener(eventName, eventHandlerProxy);\r\n            });\r\n        }\r\n    };\r\n    const addEventListeners = (ref, events) => {\r\n        if (isEventDispatcher(ref)) {\r\n            events.forEach((eventName) => {\r\n                ref.addEventListener(eventName, eventHandlerProxy);\r\n            });\r\n        }\r\n    };\r\n    const ref = writable();\r\n    const eventNames = writable([]);\r\n    watch([ref, eventNames], ([$ref, $eventNames]) => {\r\n        addEventListeners($ref, $eventNames);\r\n        return () => cleanupEventListeners($ref, $eventNames);\r\n    });\r\n    // get all event callbacks from component\r\n    onMount(() => {\r\n        eventNames.set(Object.keys(component.$$.callbacks));\r\n    });\r\n    const updateRef = (newRef) => {\r\n        ref.set(newRef);\r\n    };\r\n    return {\r\n        updateRef\r\n    };\r\n};\r\n", "import { getContext, onDestroy } from 'svelte';\r\nexport const usePlugins = (params) => {\r\n    const pluginContextName = 'threlte-plugin-context';\r\n    const plugins = getContext(pluginContextName);\r\n    if (!plugins)\r\n        return;\r\n    const pluginsReturns = Object.values(plugins)\r\n        .map((plugin) => plugin(params))\r\n        .filter(Boolean);\r\n    const pluginsProps = pluginsReturns.flatMap((callback) => callback.pluginProps ?? []);\r\n    let refCleanupCallbacks = [];\r\n    onDestroy(() => {\r\n        refCleanupCallbacks.forEach((callback) => callback());\r\n    });\r\n    const updateRef = (ref) => {\r\n        refCleanupCallbacks.forEach((callback) => callback());\r\n        refCleanupCallbacks = [];\r\n        pluginsReturns.forEach((callback) => {\r\n            const cleanupCallback = callback.onRefChange?.(ref);\r\n            if (cleanupCallback) {\r\n                refCleanupCallbacks.push(cleanupCallback);\r\n            }\r\n        });\r\n    };\r\n    const updateProps = (props) => {\r\n        pluginsReturns.forEach((callback) => {\r\n            callback.onPropsChange?.(props);\r\n        });\r\n    };\r\n    const updateRestProps = (restProps) => {\r\n        pluginsReturns.forEach((callback) => {\r\n            callback.onRestPropsChange?.(restProps);\r\n        });\r\n    };\r\n    return {\r\n        updateRef,\r\n        updateProps,\r\n        updateRestProps,\r\n        pluginsProps\r\n    };\r\n};\r\n", "import { useThrelte } from '../../../hooks/useThrelte';\r\nimport { resolvePropertyPath } from './resolvePropertyPath';\r\nconst ignoredProps = new Set(['$$scope', '$$slots', 'type', 'args', 'attach', 'instance']);\r\nconst updateProjectionMatrixKeys = new Set([\r\n    'fov',\r\n    'aspect',\r\n    'near',\r\n    'far',\r\n    'left',\r\n    'right',\r\n    'top',\r\n    'bottom',\r\n    'zoom'\r\n]);\r\n/**\r\n * Only scalar values are memoized, objects and arrays are considered\r\n * non-equa by default, to ensure reactivity works as you would\r\n * expect in svelte.\r\n * @param value\r\n * @returns\r\n */\r\nexport const memoizeProp = (value) => {\r\n    // scalar values are memoized\r\n    if (typeof value === 'string')\r\n        return true;\r\n    if (typeof value === 'number')\r\n        return true;\r\n    if (typeof value === 'boolean')\r\n        return true;\r\n    if (typeof value === 'undefined')\r\n        return true;\r\n    if (value === null)\r\n        return true;\r\n    // objects and arrays cannot be reliably memoized\r\n    return false;\r\n};\r\nconst createSetter = (target, key, value) => {\r\n    if (!Array.isArray(value) &&\r\n        typeof value === 'number' &&\r\n        typeof target[key]?.setScalar === 'function' &&\r\n        // colors do have a setScalar function, but we don't want to use it, because\r\n        // the hex notation (i.e. 0xff0000) is very popular and matches the number\r\n        // type. So we exclude colors here.\r\n        !target[key]?.isColor) {\r\n        // edge case of setScalar setters\r\n        return (target, key, value) => {\r\n            target[key].setScalar(value);\r\n        };\r\n    }\r\n    else {\r\n        if (typeof target[key]?.set === 'function') {\r\n            // if the property has a \"set\" function, we can use it\r\n            if (Array.isArray(value)) {\r\n                return (target, key, value) => {\r\n                    target[key].set(...value);\r\n                };\r\n            }\r\n            else {\r\n                return (target, key, value) => {\r\n                    target[key].set(value);\r\n                };\r\n            }\r\n        }\r\n        else {\r\n            // otherwise, we just set the value\r\n            return (target, key, value) => {\r\n                target[key] = value;\r\n            };\r\n        }\r\n    }\r\n};\r\nexport const useProps = () => {\r\n    const { invalidate } = useThrelte();\r\n    const memoizedProps = new Map();\r\n    const memoizedSetters = new Map();\r\n    const setProp = (instance, propertyPath, value, options) => {\r\n        if (memoizeProp(value)) {\r\n            const memoizedProp = memoizedProps.get(propertyPath);\r\n            if (memoizedProp && memoizedProp.instance === instance && memoizedProp.value === value) {\r\n                return;\r\n            }\r\n            memoizedProps.set(propertyPath, {\r\n                instance,\r\n                value\r\n            });\r\n        }\r\n        const { key, target } = resolvePropertyPath(instance, propertyPath);\r\n        if (value !== undefined && value !== null) {\r\n            const memoizedSetter = memoizedSetters.get(propertyPath);\r\n            if (memoizedSetter) {\r\n                memoizedSetter(target, key, value);\r\n            }\r\n            else {\r\n                const setter = createSetter(target, key, value);\r\n                memoizedSetters.set(propertyPath, setter);\r\n                setter(target, key, value);\r\n            }\r\n        }\r\n        else {\r\n            createSetter(target, key, value)(target, key, value);\r\n        }\r\n        if (options.manualCamera)\r\n            return;\r\n        if (updateProjectionMatrixKeys.has(key) &&\r\n            (target.isPerspectiveCamera || target.isOrthographicCamera)) {\r\n            target.updateProjectionMatrix();\r\n        }\r\n    };\r\n    const updateProps = (instance, props, options) => {\r\n        for (const key in props) {\r\n            if (!ignoredProps.has(key) && !options.pluginsProps?.includes(key)) {\r\n                setProp(instance, key, props[key], options);\r\n            }\r\n            invalidate();\r\n        }\r\n    };\r\n    return {\r\n        updateProps\r\n    };\r\n};\r\n", null, "import * as THREE from 'three';\r\nimport TComp from './T.svelte';\r\nconst catalogue = {};\r\n/**\r\n * Extends the default THREE namespace and allows using custom Three.js objects with `<T>`.\r\n *\r\n * @example\r\n * ```svelte\r\n * <script>\r\n * \timport { extend, T } from 'threlte'\r\n * \timport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\r\n *\r\n * \textend({ OrbitControls })\r\n * </script>\r\n *\r\n * <T.OrbitControls />\r\n * ```\r\n */\r\nexport const extend = (extensions) => {\r\n    Object.assign(catalogue, extensions);\r\n};\r\nconst augmentConstructorArgs = (args, is) => {\r\n    const module = catalogue[is] || THREE[is];\r\n    if (!module) {\r\n        throw new Error(`No Three.js module found for ${is}. Did you forget to extend the catalogue?`);\r\n    }\r\n    return {\r\n        ...args,\r\n        props: {\r\n            ...args.props,\r\n            is: module\r\n        }\r\n    };\r\n};\r\nconst proxyTConstructor = (is) => {\r\n    return new Proxy(class {\r\n    }, {\r\n        construct(_, [args]) {\r\n            const castedArgs = args;\r\n            return new TComp(augmentConstructorArgs(castedArgs, is));\r\n        }\r\n    });\r\n};\r\n/**\r\n * ## `<T>`\r\n *\r\n * Threlte's `<T>` component is a wrapper around Three.js objects. It is a generic component that can be used to create any Three.js object.\r\n *\r\n * @example\r\n *\r\n * ```svelte\r\n * <script>\r\n * \timport { T } from 'threlte'\r\n * </script>\r\n *\r\n * <T.PerspectiveCamera makeDefault />\r\n *\r\n * <T.Mesh>\r\n * \t<T.BoxGeometry />\r\n * \t<T.MeshBasicMaterial color=\"red\" />\r\n * </T.Mesh>\r\n * ```\r\n */\r\nexport const T = new Proxy(class {\r\n}, {\r\n    construct(_, [args]) {\r\n        const castedArgs = args;\r\n        return new TComp(castedArgs);\r\n    },\r\n    get(_, is) {\r\n        return proxyTConstructor(is);\r\n    }\r\n});\r\n", "import { getContext, setContext } from 'svelte';\r\nexport function injectPlugin(nameOrNamedPlugin, maybePlugin) {\r\n    const contextName = 'threlte-plugin-context';\r\n    if (Array.isArray(nameOrNamedPlugin)) {\r\n        const [name, plugin] = nameOrNamedPlugin;\r\n        setContext(contextName, {\r\n            ...getContext(contextName),\r\n            [name]: plugin\r\n        });\r\n    }\r\n    else {\r\n        const name = nameOrNamedPlugin;\r\n        const plugin = maybePlugin;\r\n        if (!plugin)\r\n            return;\r\n        setContext(contextName, {\r\n            ...getContext(contextName),\r\n            [name]: plugin\r\n        });\r\n    }\r\n}\r\n", "export function createPlugin(name, plugin) {\r\n    return [name, plugin];\r\n}\r\n", "import { getContext, onDestroy } from 'svelte';\r\nimport { readable, writable } from 'svelte/store';\r\nimport { DAG } from '../frame-scheduling';\r\nimport { browser } from '../lib/browser';\r\nimport { useThrelte } from './useThrelte';\r\nexport function useTask(keyOrFn, fnOrOptions, options) {\r\n    if (!browser) {\r\n        return {\r\n            task: undefined,\r\n            start: () => undefined,\r\n            stop: () => undefined,\r\n            started: readable(false)\r\n        };\r\n    }\r\n    let key;\r\n    let fn;\r\n    let opts;\r\n    if (DAG.isKey(keyOrFn)) {\r\n        key = keyOrFn;\r\n        fn = fnOrOptions;\r\n        opts = options;\r\n    }\r\n    else {\r\n        key = Symbol('useTask');\r\n        fn = keyOrFn;\r\n        opts = fnOrOptions;\r\n    }\r\n    const ctx = useThrelte();\r\n    let stage = ctx.mainStage;\r\n    if (opts) {\r\n        if (opts.stage) {\r\n            if (DAG.isValue(opts.stage)) {\r\n                stage = opts.stage;\r\n            }\r\n            else {\r\n                const maybeStage = ctx.scheduler.getStage(opts.stage);\r\n                if (!maybeStage) {\r\n                    throw new Error(`No stage found with key ${opts.stage.toString()}`);\r\n                }\r\n                stage = maybeStage;\r\n            }\r\n        }\r\n        else if (opts.after) {\r\n            if (Array.isArray(opts.after)) {\r\n                for (let index = 0; index < opts.after.length; index++) {\r\n                    const element = opts.after[index];\r\n                    if (DAG.isValue(element)) {\r\n                        stage = element.stage;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else if (DAG.isValue(opts.after)) {\r\n                stage = opts.after.stage;\r\n            }\r\n        }\r\n        else if (opts.before) {\r\n            if (Array.isArray(opts.before)) {\r\n                for (let index = 0; index < opts.before.length; index++) {\r\n                    const element = opts.before[index];\r\n                    if (DAG.isValue(element)) {\r\n                        stage = element.stage;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else if (DAG.isValue(opts.before)) {\r\n                stage = opts.before.stage;\r\n            }\r\n        }\r\n    }\r\n    const { autoInvalidations } = getContext('threlte-internal-context');\r\n    const started = writable(false);\r\n    const task = stage.createTask(key, fn, opts);\r\n    const start = () => {\r\n        started.set(true);\r\n        if (opts?.autoInvalidate ?? true) {\r\n            autoInvalidations.add(fn);\r\n        }\r\n        task.start();\r\n    };\r\n    const stop = () => {\r\n        started.set(true);\r\n        if (opts?.autoInvalidate ?? true) {\r\n            autoInvalidations.delete(fn);\r\n        }\r\n        task.stop();\r\n    };\r\n    if (opts?.autoStart ?? true) {\r\n        start();\r\n    }\r\n    else {\r\n        stop();\r\n    }\r\n    onDestroy(() => {\r\n        if (!stage)\r\n            return;\r\n        stage.removeTask(key);\r\n    });\r\n    return {\r\n        task,\r\n        start,\r\n        stop,\r\n        started: {\r\n            subscribe: started.subscribe\r\n        }\r\n    };\r\n}\r\n", "import { useThrelte } from './useThrelte';\r\n/**\r\n * Creates a stage and returns it. If the stage already exists, it is returned.\r\n *\r\n * @param key The key of the stage.\r\n * @param options Options for creating the stage.\r\n */\r\nexport function useStage(key, options) {\r\n    const { scheduler } = useThrelte();\r\n    return scheduler.getStage(key) ?? scheduler.createStage(key, options);\r\n}\r\n", "import { getContext } from 'svelte';\r\nimport { derived } from 'svelte/store';\r\nexport function useThrelteUserContext(namespace, value, options) {\r\n    const userCtxStore = getContext('threlte-user-context');\r\n    if (!userCtxStore) {\r\n        throw new Error('No user context store found, did you invoke this function outside of your main <Canvas> component?');\r\n    }\r\n    // return the plain user context store\r\n    if (!namespace) {\r\n        return {\r\n            subscribe: userCtxStore.subscribe\r\n        };\r\n    }\r\n    // return a specific user context entry\r\n    if (namespace && !value) {\r\n        return derived(userCtxStore, (ctx) => ctx[namespace]);\r\n    }\r\n    // we are possibly setting a new user context entry here\r\n    userCtxStore.update((ctx) => {\r\n        if (namespace in ctx) {\r\n            // skip is the default value\r\n            if (!options || options.existing === 'skip')\r\n                return ctx;\r\n            if (options.existing === 'merge') {\r\n                Object.assign(ctx[namespace], value);\r\n                return ctx;\r\n            }\r\n        }\r\n        // also handles options.existing === 'replace'\r\n        ctx[namespace] = value;\r\n        return ctx;\r\n    });\r\n    return userCtxStore.current[namespace];\r\n}\r\n", "import { getContext, onDestroy } from 'svelte';\r\nimport { readable, writable } from 'svelte/store';\r\nimport { browser } from '../../lib/browser';\r\nimport { useLegacyFrameCompatibilityContext } from './utils';\r\nimport { useThrelte } from '../useThrelte';\r\nconst orderToKey = (order) => `useFrame-order-${order.toString()}`;\r\n/**\r\n * Adds a handler to threltes unified render loop.\r\n *\r\n * `start` and `stop` functions are returned and the options allow\r\n * setting the handler to not start automatically.\r\n *\r\n * Provide an order to have your framehandlers running in a specific order.\r\n * Handlers are ordered from low to high when executing.\r\n * @param {(ctx: ThrelteContext, delta: number) => void} fn callback function\r\n * @param {ThrelteUseFrameOptions} options options\r\n * @returns {ThrelteUseFrame}\r\n */\r\nexport const useFrame = (fn, options) => {\r\n    if (!browser) {\r\n        return {\r\n            start: () => undefined,\r\n            stop: () => undefined,\r\n            started: readable(false)\r\n        };\r\n    }\r\n    const started = writable(false);\r\n    const ctx = useThrelte();\r\n    const { useFrameOrders } = useLegacyFrameCompatibilityContext();\r\n    const { autoInvalidations } = getContext('threlte-internal-context');\r\n    let order = options?.order ?? 0;\r\n    while (useFrameOrders.includes(order)) {\r\n        order += 0.01;\r\n    }\r\n    useFrameOrders.push(order);\r\n    const key = orderToKey(order);\r\n    const proxy = (delta) => {\r\n        fn(ctx, delta);\r\n    };\r\n    const task = ctx.mainStage.createTask(key, proxy, {\r\n        after: useFrameOrders.filter((o) => o < order).map((o) => orderToKey(o)),\r\n        before: useFrameOrders.filter((o) => o > order).map((o) => orderToKey(o))\r\n    });\r\n    const start = () => {\r\n        started.set(true);\r\n        if (options?.invalidate ?? true) {\r\n            autoInvalidations.add(fn);\r\n        }\r\n        task.start();\r\n    };\r\n    const stop = () => {\r\n        started.set(true);\r\n        if (options?.invalidate ?? true) {\r\n            autoInvalidations.delete(fn);\r\n        }\r\n        task.stop();\r\n    };\r\n    if (options?.autostart ?? true) {\r\n        start();\r\n    }\r\n    else {\r\n        stop();\r\n    }\r\n    onDestroy(() => {\r\n        ctx.mainStage.removeTask(key);\r\n        useFrameOrders.splice(useFrameOrders.indexOf(order), 1);\r\n    });\r\n    return {\r\n        start,\r\n        stop,\r\n        started: {\r\n            subscribe: started.subscribe\r\n        }\r\n    };\r\n};\r\n", "import { onDestroy } from 'svelte';\r\nimport { browser } from '../../lib/browser';\r\nimport { orderToKey, useLegacyFrameCompatibilityContext } from './utils';\r\nimport { useThrelte } from '../useThrelte';\r\n/**\r\n * Adds a handler that is called on every invalidated frame. This handler is\r\n * only called when an actual render should happen.\r\n * @param fn\r\n * @param options\r\n * @returns\r\n */\r\nexport const useRender = (fn, options) => {\r\n    if (!browser) {\r\n        return;\r\n    }\r\n    const ctx = useThrelte();\r\n    const { useRenderOrders } = useLegacyFrameCompatibilityContext();\r\n    let order = options?.order ?? 0;\r\n    while (useRenderOrders.includes(order)) {\r\n        order += 0.01;\r\n    }\r\n    useRenderOrders.push(order);\r\n    const key = orderToKey(order);\r\n    const proxy = (delta) => {\r\n        fn(ctx, delta);\r\n    };\r\n    ctx.renderStage.createTask(key, proxy, {\r\n        after: useRenderOrders.filter((o) => o < order).map((o) => orderToKey(o)),\r\n        before: useRenderOrders.filter((o) => o > order).map((o) => orderToKey(o))\r\n    });\r\n    onDestroy(() => {\r\n        ctx.renderStage.removeTask(key);\r\n        useRenderOrders.splice(useRenderOrders.indexOf(order), 1);\r\n    });\r\n};\r\n", "import { writable } from 'svelte/store';\r\n/**\r\n * ### `asyncWritable`\r\n *\r\n * Creates a writable store that is initialized with a promise. The store also\r\n * implements the `then` and `catch` methods of the promise so that it can be\r\n * used in `await` expressions and `{#await}` blocks of Svelte.\r\n *\r\n * ```svelte\r\n * <script>\r\n *  import { asyncWritable } from '@threlte/core'\r\n *\r\n *  const asyncOp = async () => {\r\n *    // Do something async\r\n *  }\r\n *\r\n *  const store = asyncWritable(asyncOp())\r\n *  $: console.log($store) // asyncOp result\r\n * </script>\r\n *\r\n * <h1>\r\n *  {#await store then data}\r\n *    // Do something with the data\r\n *  {/await}\r\n * </h1>\r\n * ```\r\n *\r\n * If an error occurs in the promise, the error will be logged to the console\r\n * and the error can be accessed via the `error` property of the store with in\r\n * turn is a store.\r\n *\r\n * ```svelte\r\n * <script>\r\n *  import { asyncWritable } from '@threlte/core'\r\n *\r\n *  const asyncOp = async () => {\r\n *    throw new Error('Something went wrong')\r\n *  }\r\n *\r\n *  const store = asyncWritable(asyncOp())\r\n *  const error = store.error\r\n *\r\n *  $: console.log($store) // undefined\r\n *  $: console.log($error) // Error: Something went wrong\r\n * </script>\r\n * ```\r\n */\r\nexport const asyncWritable = (promise) => {\r\n    const store = writable(undefined);\r\n    const error = writable(undefined);\r\n    promise\r\n        .then((result) => {\r\n        store.set(result);\r\n    })\r\n        .catch((e) => {\r\n        console.error('Error in asyncWritable:', e.message);\r\n        error.set(e);\r\n    });\r\n    return Object.assign(Object.assign(promise, store), { error, promise });\r\n};\r\n", "import { asyncWritable } from '../lib/asyncWritable';\r\nimport { useCache } from '../lib/cache';\r\nexport function useLoader(Proto, options) {\r\n    const { remember, clear: clearCacheItem } = useCache();\r\n    let loader;\r\n    const initializeLoader = () => {\r\n        // Type-wrestling galore\r\n        const lazyLoader = new Proto(...(options?.args ?? []));\r\n        // extend the loader if necessary\r\n        options?.extend?.(lazyLoader);\r\n        return lazyLoader;\r\n    };\r\n    const load = (input, options) => {\r\n        // Allow Async and Sync loaders\r\n        const loadResource = async (url) => {\r\n            if (!loader) {\r\n                loader = initializeLoader();\r\n            }\r\n            if ('loadAsync' in loader) {\r\n                const result = await loader.loadAsync(url, options?.onProgress);\r\n                return options?.transform?.(result) ?? result;\r\n            }\r\n            else {\r\n                return new Promise((resolve, reject) => {\r\n                    ;\r\n                    loader.load(url, (data) => resolve(options?.transform?.(data) ?? data), (event) => options?.onProgress?.(event), reject);\r\n                });\r\n            }\r\n        };\r\n        if (Array.isArray(input)) {\r\n            // map over the input array and return an array of promises\r\n            const promises = input.map((url) => {\r\n                return remember(() => loadResource(url), [Proto, url]);\r\n            });\r\n            // return an AsyncWritable that resolves to the array of promises\r\n            const store = asyncWritable(Promise.all(promises));\r\n            return store; // TODO: Dirty escape hatch\r\n        }\r\n        else if (typeof input === 'string') {\r\n            const promise = remember(() => loadResource(input), [Proto, input]);\r\n            // return an AsyncWritable that resolves to the promise\r\n            const store = asyncWritable(promise);\r\n            return store; // TODO: Dirty escape hatch\r\n        }\r\n        else {\r\n            // map over the input object and return an array of promises\r\n            const promises = Object.values(input).map((url) => {\r\n                return remember(() => loadResource(url), [Proto, url]);\r\n            });\r\n            // return an AsyncWritable that resolves to the object of promises\r\n            const store = asyncWritable(Promise.all(promises).then((results) => {\r\n                return Object.fromEntries(Object.entries(input).map(([key], i) => [key, results[i]]));\r\n            }));\r\n            return store; // TODO: Dirty escape hatch\r\n        }\r\n    };\r\n    const clear = (input) => {\r\n        if (Array.isArray(input)) {\r\n            input.forEach((url) => {\r\n                clearCacheItem([Proto, url]);\r\n            });\r\n        }\r\n        else if (typeof input === 'string') {\r\n            clearCacheItem([Proto, input]);\r\n        }\r\n        else {\r\n            Object.entries(input).forEach(([key, url]) => {\r\n                clearCacheItem([Proto, key, url]);\r\n            });\r\n        }\r\n    };\r\n    return {\r\n        load,\r\n        clear,\r\n        loader\r\n    };\r\n}\r\n// Type tests\r\n// class WithConstructorParameters {\r\n//   constructor(hello: 'abc' | 'def') {\r\n//     console.log(hello)\r\n//   }\r\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\r\n//     return new Promise((r) => r('hello'))\r\n//   }\r\n// }\r\n// class WithOptionalConstructorParameters {\r\n//   constructor(hello?: string) {\r\n//     console.log(hello)\r\n//   }\r\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\r\n//     return new Promise((r) => r('hello'))\r\n//   }\r\n// }\r\n// class WithoutConstructorParameters {\r\n//   constructor() {\r\n//     console.log('without')\r\n//   }\r\n//   loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<any> {\r\n//     return new Promise((r) => r('hello'))\r\n//   }\r\n// }\r\n// const shouldFail = () => {\r\n//   useLoader(WithConstructorParameters)\r\n//   useLoader(WithoutConstructorParameters, {\r\n//     args: ['hello']\r\n//   })\r\n// }\r\n// const shouldSucceed = () => {\r\n//   useLoader(WithConstructorParameters, {\r\n//     args: ['abc']\r\n//   })\r\n//   useLoader(WithConstructorParameters, {\r\n//     args: ['abc'],\r\n//     extend(loader) {\r\n//       // …\r\n//     }\r\n//   })\r\n//   useLoader(WithOptionalConstructorParameters)\r\n//   useLoader(WithOptionalConstructorParameters, {\r\n//     extend(loader) {\r\n//       // …\r\n//     }\r\n//   })\r\n//   useLoader(WithOptionalConstructorParameters, {\r\n//     args: [],\r\n//     extend(loader) {\r\n//       // …\r\n//     }\r\n//   })\r\n//   useLoader(WithOptionalConstructorParameters, {\r\n//     args: ['hello'],\r\n//     extend(loader) {\r\n//       // …\r\n//     }\r\n//   })\r\n//   useLoader(WithOptionalConstructorParameters, {\r\n//     args: ['hello']\r\n//   })\r\n//   useLoader(WithoutConstructorParameters)\r\n//   useLoader(WithoutConstructorParameters, {\r\n//     extend(loader) {\r\n//       // …\r\n//     }\r\n//   })\r\n// }\r\n", "import { get_current_component } from 'svelte/internal';\r\nimport { writable } from 'svelte/store';\r\nimport { watch } from './storeUtils';\r\n/**\r\n * ### `forwardEventHandlers`\r\n *\r\n * Natively, Svelte has no way of passing down event handlers inside a\r\n * component to a child component. Events have to be hand-wired upstream. This\r\n * function allows you to forward event handlers from a parent component to a child\r\n * component as if they were declared on the child component itself.\r\n *\r\n * ```svelte\r\n * <!-- Child.svelte -->\r\n * <script>\r\n * \timport { forwardEventHandlers } from '@threlte/core'\r\n * \tconst dispatchingComponent = forwardEventHandlers()\r\n * </script>\r\n *\r\n * <OtherChildComponent bind:this={$dispatchingComponent} />\r\n * ```\r\n *\r\n * Now, when implementing `<Child>` and adding event handlers via `on:eventname`,\r\n * those event handlers will be forwarded to `<OtherChildComponent>`:\r\n *\r\n * ```svelte\r\n * <!-- Parent.svelte -->\r\n * <script>\r\n * \timport Child from './Child.svelte'\r\n * </script>\r\n *\r\n * <Child on:click={() => console.log('clicked')} />\r\n * ```\r\n *\r\n * If `OtherChildComponent.svelte` now dispatches a `click` event, the event handler\r\n * in `Parent.svelte` will be called.\r\n */\r\nexport const forwardEventHandlers = () => {\r\n    const component = get_current_component();\r\n    const dispatchingComponent = writable(undefined);\r\n    watch(dispatchingComponent, (dispatchingComponent) => {\r\n        if (!dispatchingComponent)\r\n            return;\r\n        Object.entries(component.$$.callbacks).forEach((callback) => {\r\n            const [key, value] = callback;\r\n            if (key in dispatchingComponent.$$.callbacks &&\r\n                Array.isArray(dispatchingComponent.$$.callbacks[key])) {\r\n                dispatchingComponent.$$.callbacks[key].push(...value);\r\n            }\r\n            else {\r\n                dispatchingComponent.$$.callbacks[key] = value;\r\n            }\r\n        });\r\n    });\r\n    return dispatchingComponent;\r\n};\r\n"],
  "mappings": "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",
  "names": ["all", "Map", "on", "type", "handler", "handlers", "get", "push", "set", "off", "splice", "indexOf", "emit", "evt", "slice", "map", "key", "key", "key", "key", "start", "value", "_a", "entry", "renderer", "ctx", "initialized", "autoRender", "key", "instance", "key", "size", "instance", "cleanup", "ref", "key", "target", "value", "instance", "ctx", "T", "contextName", "key", "element", "key", "orderToKey", "key", "key", "options", "_a", "key", "dispatchingComponent", "key"]
}
